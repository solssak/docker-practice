## 유틸리티 컨테이너(utility container)
### 지금까지 배운 내용
- 우리는 Docker Compose를 사용해서 여러 애플리케이션 컨테이너를 구성하고 실행해왔음.
- 이 컨테이너들에는 항상 애플리케이션 코드 + 실행 환경이 함께 포함되어 있었음.
- 예) Node.js API 서버, React 프론트엔드, 데이터베이스 등
### 유틸리티 컨테이너란?
- 공식 용어는 아님.
- 애플리케이션을 실행하지 않고, 단지 특정 환경만 갖춘 컨테이너를 의미.
- 예) Node.js 환경이 설치된 컨테이너, PHP 실행 환경만 있는 컨테이너 등
### 유틸리티 컨테이너의 활용
컨테이너를 애플리케이션 실행 용도로만 쓰는 것이 아니라,
특정 작업을 위한 도구처럼 사용할 수 있다는 것이 핵심.

예를 들어, 컨테이너를 실행할 때 이미지 이름 뒤에 **명령어(command)**를 붙여서
docker run my-image <command> 형태로 실행 가능.

이렇게 하면, 작업만 하고 종료되는 일회성 컨테이너로 활용 가능.

### 왜 중요한가?
도커를 단순히 서버 실행 용도로만 쓰는 것이 아니라,
빌드, 테스트, 데이터 마이그레이션 등 다양한 작업을 분리된 환경에서 실행할 수 있음.

이 방식은 팀 협업 시에도 개발 환경을 통일하고 오류를 줄이는 데 매우 효과적임.

### 왜 '유틸리티 컨테이너'라는 걸 구분해서 쓰는가?
위 설명으로는 도커가 해결하려는 문제와 크게 차이가 없는 것 같지만,
"어디에서 실행하느냐, 언제 실행하느냐, 어떻게 분리하느냐"에 있다고 한다.

**도커만 쓰는 경우** (애플리케이션 컨테이너)
- NestJS 컨테이너가 있고, 안에서 npm run start, npm run migrate 등 다 실행
- 애플리케이션과 스크립트가 같은 컨테이너에 섞임
- 무겁고, 재사용성이 떨어지고, 관리 어려움

**도커를 '유틸리티 컨테이너'로 쓰는 경우**
- NestJS는 NestJS 대로 컨테이너
- 마이그레이션은 node 이미지로 짧게 실행
- 빌드는 node:18에서 따로, 린트도 따로

**즉, 책임을 역할별로 구분하고, 일회성 작업은 일회성 컨테이너로 처리한다.**

정리하면, 도커는 **한 번 만든 환경을 어디서든 똑같이 실행할 수 있게 해주는 도구**인데, 역할에 따라 컨테이너를 나누면
작업 목적에 알맞는, 작고 유연한 실행 단위를 만들 수 있다.
