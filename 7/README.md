## 유틸리티 컨테이너(utility container)
### 지금까지 배운 내용
- 우리는 Docker Compose를 사용해서 여러 애플리케이션 컨테이너를 구성하고 실행해왔음.
- 이 컨테이너들에는 항상 애플리케이션 코드 + 실행 환경이 함께 포함되어 있었음.
- 예) Node.js API 서버, React 프론트엔드, 데이터베이스 등
### 유틸리티 컨테이너란?
- 공식 용어는 아님.
- 애플리케이션을 실행하지 않고, 단지 특정 환경만 갖춘 컨테이너를 의미.
- 예) Node.js 환경이 설치된 컨테이너, PHP 실행 환경만 있는 컨테이너 등
### 유틸리티 컨테이너의 활용
컨테이너를 애플리케이션 실행 용도로만 쓰는 것이 아니라,
특정 작업을 위한 도구처럼 사용할 수 있다는 것이 핵심.

예를 들어, 컨테이너를 실행할 때 이미지 이름 뒤에 **명령어(command)**를 붙여서
docker run my-image <command> 형태로 실행 가능.

이렇게 하면, 작업만 하고 종료되는 일회성 컨테이너로 활용 가능.

### 왜 중요한가?
도커를 단순히 서버 실행 용도로만 쓰는 것이 아니라,
빌드, 테스트, 데이터 마이그레이션 등 다양한 작업을 분리된 환경에서 실행할 수 있음.

이 방식은 팀 협업 시에도 개발 환경을 통일하고 오류를 줄이는 데 매우 효과적임.

### 왜 '유틸리티 컨테이너'라는 걸 구분해서 쓰는가?
위 설명으로는 도커가 해결하려는 문제와 크게 차이가 없는 것 같지만,
"어디에서 실행하느냐, 언제 실행하느냐, 어떻게 분리하느냐"에 있다고 한다.

**도커만 쓰는 경우** (애플리케이션 컨테이너)
- NestJS 컨테이너가 있고, 안에서 npm run start, npm run migrate 등 다 실행
- 애플리케이션과 스크립트가 같은 컨테이너에 섞임
- 무겁고, 재사용성이 떨어지고, 관리 어려움

**도커를 '유틸리티 컨테이너'로 쓰는 경우**
- NestJS는 NestJS 대로 컨테이너
- 마이그레이션은 node 이미지로 짧게 실행
- 빌드는 node:18에서 따로, 린트도 따로

**즉, 책임을 역할별로 구분하고, 일회성 작업은 일회성 컨테이너로 처리한다.**

정리하면, 도커는 **한 번 만든 환경을 어디서든 똑같이 실행할 수 있게 해주는 도구**인데, 역할에 따라 컨테이너를 나누면
작업 목적에 알맞는, 작고 유연한 실행 단위를 만들 수 있다.

### 사례와 함께 알아보기
**기존 방식의 한계**
- Node.js가 설치된 컨테이너를 잠깐 실행해서 `npm init` 실행이 필요함.
- 근데 `npm`은 Node.js가 설치된 시스템에서만 실행 가능
- 즉, 앱을 만들기 위해 로컬에 Node 설치가 필요
  > 도커 철학인 **"로컬 환경에 아무것도 설치하지 않음"**과 충돌
**유틸리티 컨테이너를 활용하면?**
- Node.js가 설치된 컨테이너를 잠깐 실행해서 `npm init`을 실행
- 즉, 앱을 만들기 위한 환경도 컨테이너로 대체
- 호스트 시스템에 아무것도 설치할 필요 없이 프로젝트 생성 가능
  `docker run --rm -it -v $(pwd):/app -w /app node:18 npm init`
1. Node.js 18 이미지에서
2. 현재 디렉토리를 컨테이너 내부 `/app`에 마운트하고
3. 그 위치에서 `npm init`을 실행

즉, 앱을 **실행**하는 것을 넘어서, 앱을 **생성**하는 과정까지 컨테이너화할 수 있다는 것

### `docker exec`
- 이미 실행중인 컨테이너 안에서 명령어를 추가로 실행할 때 사용할 수 있다.
- 컨테이너 내부에서 무언가를 '추가 실행'하는 느낌
```
docker exec -it my_container bash       # 쉘 진입
docker exec -it my_container npm init   # 실행 중인 컨테이너에서 npm 초기화
```
- 주요 특징:
  - 대상 컨테이너는 이미 실행 중이어야 함
  - CMD/ENTRYPOINT는 영향을 받지 않음 (계속 실행 중)
  - -it 플래그로 상호작용 가능
### 디폴트 명령 오버라이드
- 도커 이미지를 실행할 때 Dockerfile의 CMD를 무시하고, 다른 명령어로 실행할 수 있음
- "이 이미지를 실행하되, 내가 원하는 작업만 해줘"라는 식의 일회성 실행
```
docker run -it node              # → node REPL (CMD 그대로)
docker run -it node npm init    # → `node` CMD 무시하고 `npm init` 실행
```
- 주요 특징:
  - 컨테이너가 새로 시작될 때 실행됨
  - Dockerfile의 CMD를 완전히 대체함
  - 일회성 작업(빌드, 초기화 등)에 적합
### `docker exec`과 디폴트 명령 오버라이드
**헷갈렸던 부분**
`docker exec`로 진입해서 디폴트 명령 오버라이드를 쓰는건가?
`docker exec`는 디폴트 명령과는 별개로 컨테이너 안에서 명령을 추가 실행하는 도구
반면 `docker run`의 명령 오버라이드는 Dockerfile의 CMD를 대체하는 기능.
즉, 목적과 실행 타이밍이 다름!
| 항목            | `docker exec`                  | 디폴트 명령 오버라이드 (`docker run`)     |
|-----------------|--------------------------------|--------------------------------------------|
| 대상 컨테이너   | 이미 실행 중                   | 새로 실행                                   |
| 목적            | 추가 작업 실행                 | 기본 명령 대체                              |
| CMD 영향        | 영향 없음                      | CMD 무시됨                                  |
| 사용 시점       | 실행 중인 컨테이너 내부        | 컨테이너 시작 시                            |
| 예시            | `docker exec -it app bash`     | `docker run -it node npm init`   
