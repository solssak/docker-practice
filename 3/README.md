# 3: 데이터 관리 및 볼륨으로 작업하기
## Docker에서 다루는 데이터의 종류와 저장 방식
### 1. 애플리케이션 코드 및 실행 환경 (읽기 전용)
- 사용자가 작성한 소스 코드와 실행 환경이 포함.
- Dockerfile을 사용해 이미지에 복사되며, 빌드된 이미지는 읽기 전용(immutable) 상태가 됨.
- 변경하려면 새 이미지를 빌드해야함.(읽기 전용)
- 실행 중인 컨테이너는 애플리케이션 코드를 수정할 수 없음.

### 2. 임시 애플리케이션 데이터 (읽기/쓰기, 컨테이너 내부 저장)
- 애플리케이션 실행 중 생성되며, 컨테이너가 종료되면 사라지는 데이터.
- ex. 웹사이트에서 사용자가 input에 입력한 데이터.
- 컨테이너 내 메모리, 파일 시스템, 데이터베이스 캐시 등에 저장됨.
- 컨테이너가 종료되면 데이터가 유실됨 -> 일시적인 데이터로 문제 없음.
- 컨테이너의 read-write layer에 저장되며, 이는 Docker가 내부적으로 관리

### 3. 영구 애플리케이션 데이터 (읽기/쓰기, 컨테이너 외부 저장)
- 애플리케이션이 실행되면서 장기간 유지해야 하는 데이터.
- ex. 계정 정보, DB에 저장된 데이터, 로그 등
- 컨테이너가 중지되거나 새로운 버전이 배포되더라도 데이터는 유지 되어야함.
- Docker 볼륨 를 사용해서 저장 -> 컨테이너 외부의 독립적인 저장 공간 제공.

### **Docker 데이터 유형별 비교표**

| 데이터 유형 | 저장 위치 | 특성 | 예시 |
|------------|------------|------------|------------|
| **애플리케이션 코드 및 실행 환경** | Docker 이미지 | - **읽기 전용 (Immutable)**<br>- 변경하려면 새 이미지 빌드 필요 | 소스 코드, 패키지, 환경 설정 (`package.json`, `node_modules` 등) |
| **임시 애플리케이션 데이터** | 컨테이너 내부 (read-write 레이어) | - **읽기/쓰기 가능**<br>- **컨테이너 종료 시 삭제** | 입력 폼 데이터, 캐시, 임시 로그 |
| **영구 애플리케이션 데이터** | Docker 볼륨 (호스트 저장소) | - **읽기/쓰기 가능**<br>- **컨테이너 종료 후에도 유지됨** | 사용자 계정 정보, DB 저장 데이터, 영구 로그 파일 |

### **핵심 개념**
1. **Docker 이미지는 읽기 전용** → 변경하려면 새 이미지를 빌드해야 함.
2. **임시 데이터는 컨테이너 내부의 read-write 레이어에 저장** → 컨테이너 종료 시 삭제됨.
3. **영구 데이터는 Docker 볼륨을 사용하여 컨테이너 외부에 저장** → 컨테이너가 삭제되어도 유지됨.

이 모듈에서는 **Docker 볼륨을 활용하여 영구 데이터를 안전하게 저장하는 방법**을 다루게 됩니다. 🚀

## 컨테이너 삭제 시 데이터 손실 문제
	1.	컨테이너 내부의 파일 시스템은 컨테이너가 삭제되면 함께 사라진다.
	- 컨테이너 내부에서 생성한 파일(예: feedback/awesome.txt)은 컨테이너 내부의 read-write 레이어에 저장됨.
	- 컨테이너를 중지(stop) 하면 데이터는 유지되지만, 컨테이너를 제거(remove) 하면 데이터도 함께 삭제됨.
	2.	컨테이너를 업데이트하거나 재배포할 때 문제가 발생
	- 새로운 코드를 반영하려면 새로운 Docker 이미지를 빌드하고, 기존 컨테이너를 제거한 후 새 컨테이너를 실행해야 함.
	- 기존 컨테이너를 삭제하면 내부에 저장된 데이터도 사라지므로 사용자 데이터가 유실됨.

## Docker 볼륨(Volumes) 개념 및 활용 방법

📌 문제: 컨테이너가 제거되면 내부의 데이터도 삭제됨
	- 기존 방식에서는 컨테이너 내부의 파일 시스템이 유지되지 않음.
	- 컨테이너를 제거하면 데이터도 함께 삭제됨 → 영구적으로 유지할 방법이 필요.

### Docker 볼륨(Volumes)이란?

✅ 볼륨은 호스트 머신에 저장되는 데이터 폴더이며, 컨테이너와 연결 가능
✅ 컨테이너가 삭제되더라도 볼륨은 유지됨
✅ 컨테이너와 호스트 머신이 데이터를 공유할 수 있음

📌 Dockerfile의 COPY 명령과 차이점:
	- COPY는 한 번만 실행되며, 컨테이너가 생성될 때 이미지를 기반으로 파일이 복사됨.
	- 볼륨은 지속적으로 연결되어, 컨테이너 내부에서 수정한 파일이 호스트 머신에도 반영됨.

### VOLUME을 추가했는데 데이터가 유지되지 않는 이유와 해결 방법

📌 문제: 컨테이너를 재시작하면 파일이 사라짐
  1. Dockerfile에서 VOLUME /app/feedback을 선언하면, 익명 볼륨이 자동 생성됨.
	- 하지만 익명 볼륨은 컨테이너가 삭제되면 함께 사라짐.
	- 이 때문에 컨테이너를 재시작할 때 새 볼륨이 만들어지고, 기존 데이터가 유지되지 않음.
	2. 익명 볼륨은 컨테이너가 삭제될 때 함께 제거됨.
	- 따라서 피드백 파일이 볼륨에 저장되긴 하지만, 컨테이너를 제거하면 볼륨도 삭제됨.
	- 즉, 새로운 컨테이너를 실행할 때는 완전히 새로운 볼륨이 생성되므로 기존 데이터가 남아있지 않음.

### Anonymous Volume vs. Named Volume 비교 및 활용법

| 볼륨 유형 | 생성 방식 | 컨테이너 삭제 시 유지 여부 | 데이터 관리 방식 | 사용 사례 |
|-----------|-----------|--------------------|--------------------|-----------|
| **Anonymous Volume** | `VOLUME /app/data` (Dockerfile) 또는 `-v /app/data` | ❌ 컨테이너 삭제 시 사라짐 | Docker가 자동 생성 및 관리 (경로 불명확) | **임시 데이터 저장** (로그, 캐시, 세션 데이터) |
| **Named Volume** | `docker volume create my-volume` + `-v my-volume:/app/data` | ✅ 컨테이너 삭제 후에도 유지됨 | 사용자가 직접 볼륨을 지정하고 관리 가능 | **영구 데이터 저장** (DB, 사용자 데이터, 설정 파일) |

```
// Named Volume 생성하기
docker volume create feedback-data // Named Volume 생성
docker run -p 3000:80 -d --name feedback-app -v feedback-data:/app/feedback feedback-node:latest // 컨테이너 실행 & 볼륨 연결

// 볼륨 확인 및 데이터 유지 확인
docker volume ls
docker volume inspect feedback-data // 특정 볼륨 정보 확인

docker stop feedback-app
docker rm feedback-app
docker run -p 3000:80 -d --name feedback-app -v feedback-data:/app/feedback feedback-node:latest // 컨테이너를 삭제해도 데이터가 유지되는지 테스트

docker volume prune // 사용하지 않는 정리
```
### 바인드 마운트의 개념

📌 바인드 마운트란?
바인드 마운트는 호스트 머신의 특정 디렉토리를 컨테이너 내부의 디렉토리와 직접 연결하는 방식입니다.
즉, 호스트 머신에서 변경한 파일이 컨테이너에서도 즉시 반영됨 → 개발 중 코드 변경을 실시간으로 반영하는 데 유용!

📌 기존 Docker 볼륨과의 차이점
| 볼륨 유형 | 컨테이너 삭제 후 데이터 유지 | 호스트 머신에서 직접 접근 가능 여부 | 사용 사례 |
|-----------|--------------------|--------------------|-----------|
| **명명된 볼륨 (Named Volume)** | ✅ 유지됨 | ❌ 직접 접근 어려움 (Docker가 관리) | **영구 데이터 저장** (DB, 설정 파일) |
| **익명 볼륨 (Anonymous Volume)** | ❌ 컨테이너 삭제 시 사라짐 | ❌ 직접 접근 불가 | **임시 데이터 저장** (로그, 캐시) |
| **바인드 마운트 (Bind Mount)** | ✅ 유지됨 | ✅ 직접 접근 가능 (호스트 머신의 특정 디렉토리) | **개발 환경에서 코드 변경 즉시 반영** |

📌 바인드 마운트의 역할
  - 호스트 머신의 특정 폴더와 컨테이너를 연결
  - 호스트에서 변경하면 컨테이너에서도 즉시 반영 (개발에 유용!)
  - 소스 코드, 설정 파일 등을 컨테이너와 동기화 가능
  - Docker 이미지 재빌드 없이 코드 변경 가능

📌 바인드 마운트 실행 후 발생하는 문제
  - 컨테이너 실행 후 서버가 즉시 종료됨.
  - docker logs feedback-app 실행 시 다음과 같은 오류 발생:
  ```
  Error: Cannot find module 'express'
  ```

💡 원인
  - Docker 이미지는 npm install을 실행하여 node_modules을 설치함.
  - 하지만 바인드 마운트(-v $(pwd):/app)를 추가하면 호스트 머신의 파일이 컨테이너 내부를 덮어씀.
  - 이때 호스트 머신에 node_modules가 없으면 컨테이너에서도 삭제됨 → express 같은 패키지를 찾을 수 없음.
  -> node_modules가 컨테이너에서 사라졌기 때문!

📌 해결 방법
  1. node_modules를 별도의 Docker 볼륨으로 관리
  2. 호스트 머신에서도 node_modules 설치

### **🚀 익명 볼륨 vs. 명명된 볼륨 vs. 바인드 마운트 총정리 정리**

| 비교 항목 | **익명 볼륨 (Anonymous Volume)** | **명명된 볼륨 (Named Volume)** | **바인드 마운트 (Bind Mount)** |
|-----------|--------------------|--------------------|--------------------|
| **데이터 유지** | ❌ 컨테이너 삭제 시 사라짐 | ✅ 컨테이너 삭제 후에도 유지됨 | ✅ 컨테이너 삭제 후에도 유지됨 |
| **호스트 머신에서 직접 접근 가능 여부** | ❌ 직접 접근 불가 | ❌ 직접 접근 어려움 (Docker가 내부적으로 관리) | ✅ 호스트 머신에서 직접 접근 가능 |
| **경로 지정 방식** | `-v /container/path` (호스트 경로 지정 안함) | `-v volume_name:/container/path` | `-v /absolute/host/path:/container/path` |
| **데이터 저장 위치** | Docker가 자동으로 생성한 경로 (호스트에서 접근 불가능) | Docker가 관리하는 특정 저장소 | 호스트 머신의 지정된 디렉토리 |
| **컨테이너 삭제 후 데이터 유지** | ❌ 삭제됨 | ✅ 유지됨 | ✅ 유지됨 |
| **다른 컨테이너에서 사용 가능** | ❌ 불가능 | ✅ 가능 | ✅ 가능 |
| **사용 사례** | - 임시 데이터 저장 (캐시, 로그) <br> - 성능 최적화 | - 영구 데이터 저장 (DB, 설정 파일) <br> - 여러 컨테이너에서 데이터 공유 | - 개발 환경에서 코드 변경 실시간 반영 <br> - 컨테이너와 로컬 파일 동기화 |

---

### **📌 주요 특징 요약**
✅ **익명 볼륨**  
  - 컨테이너 삭제 시 함께 삭제됨.  
  - Docker가 경로를 자동으로 관리하여, 호스트 머신에서는 접근 불가능.  
  - **임시 데이터 저장이나 성능 최적화용으로 유용**.  

✅ **명명된 볼륨**  
  - 컨테이너 삭제 후에도 유지됨.  
  - Docker가 관리하는 특정 저장소에 저장되며, 호스트 머신에서 직접 접근 불가능.  
  - **DB, 설정 파일 등 영구적으로 유지해야 하는 데이터에 적합**.  

✅ **바인드 마운트**  
  - 컨테이너 삭제 후에도 데이터 유지됨.  
  - **호스트 머신의 특정 폴더와 직접 연결되므로, 로컬 파일을 실시간으로 반영 가능**.  
  - **개발 환경에서 코드 변경이 즉시 반영되어야 할 때 유용**.  

🚀 **개발 환경에서는 바인드 마운트! 배포 환경에서는 명명된 볼륨!** 🎯

📌 궁금한 것: 익명 볼륨이 왜 필요한가? 컨테이너가 제거되면 내부의 데이터도 삭제되는 문제를 가지고 있는데?
  1. 컨테이너가 실행되는 동안 로그 데이터를 저장할 때 사용됨. (CI/CD 환경에서 빌드 파일이나 테스트 결과를 컨테이너 내부에서 테스트할 때 용이)
  2. 컨테이너가 데이터를 읽고 쓸 수 있도록 하되, 컨테이너 종료 후 데이터를 유지할 필요가 없을 때
    -> 데이터를 컨테이너 내부의 파일 시스템에 의존하지 않고 Docker가 효율적으로 관리하게 하는 목적