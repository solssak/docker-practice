# Docker 강의 총 정리 요약
## 1. 기본 개념
### 1-1.컨테이너
정의: 코드와 실행에 필요한 환경을 포함하는 **격리된 실행 단위**
특징
1. 하나의 컨테이너는 하나의 Task에 집중한다.
  - 예: 웹 서버 실행, 프론트엔드 실행, DB 실행 등
2. 재현 가능한 환경 제공 -> 배포 및 공유가 용이함.
3. 무상태(stateless): 컨테이너 내부에 저장된 데이터는 컨테이너 종료 시 사라진다.
  - 단, **볼륨(Volume)**을 사용하면 데이터 지속 가능
    -> 로컬 호스트와 폴더를 연결하여 데이터 유지

### 1-2. 이미지
정의: 컨테이너를 생성하는 설계도(청사진)
  -> 실행 가능한 상태가 아닌, 컨테이너 생성의 기반
특징:
  - 읽기 전용
  - 보통은 `Dockerfile`로 직접 만들거나 `Docker Hub`에서 가져옴
  - 여러 명령어(Layer)로 구성되며, 이 레이어는 캐시되어 재사용 가능 -> 빠른 빌드 속도
  - 공유 및 재현이 쉬움

### 1-3. 이미지와 컨테이너의 관계
- 컨테이너는 이미지 위에 만들어지는 얇은 계층의 읽기/쓰기 레이어
- 하나의 이미지로 여러 컨테이너 생성 가능
- 컨테이너에서 생성된 데이터는 이미지가 아닌 그 레이어에 기록됨
- 이미지는 절대 변경되지 않음 -> 안정적이고 공유 가능

### 1-4. 핵심 요약
- 컨테이너: 실행 가능한 앱 단위 (하나의 역할만 수행, 무상태)
- 이미지: 컨테이너를 만들기 위한 정적인 청사진 (readonly, 공유 가능)
- 컨테이너는 이미지 위에 생성되며, 이미지와 데이터를 분리함
- 볼륨을 통해 무상태인 컨테이너에 **지속성**을 부여할 수 있음
- `Dockerfile` 기반의 이미지 빌드는 레이어 단위로 효율적이고 빠르게 처리됨
  - `Dockerfile`에서 변경 가능성이 적은 작업을 상위에 배치하면 Layer cache를 효율화할 수 있음.
 
## 2. 핵심 명령어 요약
### 2-1. `docker build`
- 용도: Dockerfile을 기반으로 이미지 생성
- 주요 옵션:
  - `-t <이름:태그>`: 이미지에 이름과 태그 지정 (버전 관리에 사용됨)
  - `.` 또는 `<폴더 경로>`: 빌드 컨텍스트 지정 (Dockerfile 위치)
  - 예시
    - `docker build -t myapp:1.0 .`

### 2-2. 태그 시스템
- 목적: 동일한 이미지의 버전 구분
  - 예: `node12`,`node:14`
- 구조: `<이미지 이름>:<태그>`
  - 태그 생략 시 기본 값은 `latest`

### 2-3. `docker run`
- 용도: 이미지를 기반으로 컨테이너 실행
  - 주요 옵션:
    - `--name <이름>`: 컨테이너에 이름 지정
    - `--rm`: 컨테이너 종료 시 자동 삭제
    - `-d`: 백그라운드(detached) 실행
  - 예시
    `docker run --rm -d --name webserver nginx:latest`

### 2-3. `docker run`
- `docker push`: 로컬 이미지를 Docker Hub 등 레지스트리에 업로드
- `docker pull`: 레지스트리에서 이미지를 로컬로 다운로드
- 이미지 이름 주의 사항:
  - 기본은 DockerHub → 계정명/이미지명:태그
  - 다른 레지스트리 사용 시: 도메인/계정명/이미지명:태그
- 예시
  ```bash
  docker tag myapp:1.0 mydockerhubid/myapp:1.0
  docker push mydockerhubid/myapp:1.0
  ```

## 3. 데이터 볼륨 및 네트워킹
### 3-1. 컨테이너의 상태와 데이터 유지
- 컨테이너는 기본적으로 stateless하며, 내부에서 생성한 데이터는 종료 시 모두 사라짐.
- 컨테이너 내부 파일 시스템은 호스트와 분리되어 있으며, 기본적으로 외부와 공유되지 않음.   
✅ 문제: 컨테이너가 제거되면 생성된 데이터도 함께 삭제됨   
✅ 해결책: 볼륨(Volume) 또는 바인드 마운트(Bind Mount) 사용   

### 3-2. 볼륨(Volume) vs 바인드 마운트(Bind Mount)
| 항목       | 볼륨 (Volume)                          | 바인드 마운트 (Bind Mount)                 |
|------------|----------------------------------------|--------------------------------------------|
| 정의       | Docker가 관리하는 데이터 저장소       | 호스트의 특정 경로를 직접 연결             |
| 위치       | Docker가 자동으로 생성하고 관리       | 사용자가 명시적으로 경로 지정              |
| 사용 목적  | 데이터 유지, 공유 목적 (운영 환경 중심) | 소스 코드, 구성 파일 공유 (개발 환경 중심) |
| 장점       | 안전하고 Docker가 관리함              | 즉시 수정 가능, 실시간 반영               |
| 단점       | 호스트에서 경로 명시 안 됨             | 보안/퍼포먼스 이슈 가능                    |

> 볼륨은 명명된 볼륨과 익명 볼륨이 있음   
>   명명된 볼륨: 데이터 유지 목적, 명시적으로 사용   
>   익명 볼륨: 일시적 데이터 저장 시 유용

### 3-3. 컨테이너 간 네트워크 통신
- 기본적으로 컨테이너는 격리된 네트워크 상태
- 외부 요청은 쉽게 가능하지만, 컨테이너 간 통신은 추가 설정이 필요함

❌비추천 방식   
- 직접 IP로 접근
  -> IP는 매번 바뀔 수 있어 불안정하고 관리가 어려움

✅ 권장 방식   
- 사용자 정의 Docker 네트워크 생성
- 동일 네트워크에 있는 컨테이너 끼리는 이름으로 통신 가능
  - 도커가 자동으로 이름 -> IP 매핑을 해결함
  ```
  # 네트워크 생성
  docker network create mynetwork
  
  # 네트워크에 컨테이너 연결
  docker run -d --name db --network mynetwork postgres
  docker run -d --name backend --network mynetwork myapp
  ```
  > 이후 backend 컨테이너는 `db:포트번호` 로 DB 컨테이너에 접근 가능

### 3-4. 정리
- 컨테이너는 기본적으로 무상태이며, 데이터는 종료 시 사라진다.
- 이를 해결하기 위해 바인드 마운트나 볼륨을 사용한다.
- 바인드 마운트는 개발 환경에서 유용하고, 볼륨은 데이터 보존 목적에 적합하다.
- 컨테이너 간 통신은 Docker 네트워크를 활용해 이름 기반으로 연결하는 것이 가장 안전하고 관리하기 쉬운 방식이다.

## 4. Docker vs Docker Compose
### 4-1. Docker Compose 란?
다중 컨테이너 애플리케이션을 정의하고 실행할 수 있게 해주는 도구

### 4-2. Compose의 필요성
- 단일 컨테이너 실행은 `docker run` 명령어로 충분하지만,
- 환경 변수, 볼륨, 네트워크, 포트 등 다양한 설정이 추가되면 명령어가 길고 복잡해짐.
- 특히 다중 컨테이너 프로젝트에서는 `docker run`을 반복 작성하기 번거로움.

### 4-3. Docker Compose의 핵심 아이디어
- 설정을 **YAML 파일(docker-compose.yml)**에 정의하여 명령어 없이 구성만으로 실행 가능
- 이 파일에 여러 컨테이너의 구성(이미지, 볼륨, 네트워크, 환경 변수 등)을 한 번에 선언

### 주요 명령어
1. `docker-compose up`: `docker-compose.yml`파일을 기반으로 모든 서비스 시작
2. `docker-compose down`: 실행중인 모든 Compose 컨테이너 정리 및 네트워크 제거

### Compose 사용의 장점
- 반복 가능하고 선언적인 설정 가능
  - 프로젝트 루트에 docker-compose.yml 파일을 두면
    - → 협업자도 동일한 방식으로 컨테이너 실행 가능
- 컨테이너 간 네트워크 자동 연결
  - → 이름 기반 통신 지원
- 개발, 테스트, 배포 환경 모두에 동일한 방식 적용 가능

> Docker Compose는 다중 컨테이너 프로젝트의 설정과 실행을 간편하게 만들어주는 선언형 도구

## 5. Docker의 두 가지 주요 활용 영역
### 5-1. 로컬(Local) 개발 환경
- 도커는 개발 머신에서 격리된 환경을 제공
- 모든 의존성과 런타임을 컨테이너에 포함시켜 다중 프로젝트 간 충돌 없이 안정적 개발 가능
- 대표적 장점:
  - 시스템 전역 설정 불필요
  - 개발 환경 재현이 쉬움 (동료 개발자와 공유 가능)
  - 라이브러리/언어 버전 충돌 방지
  - 배포하지 않더라도 도커는 매우 유용
> 예: Node.js 14 프로젝트와 Node.js 20 프로젝트를 동시에 운영할 때도 문제 없음

### 5-2. 리모트(Remote) 배포 환경
- 동일한 이미지를 기반으로 컨테이너를 원격 서버에 배포 가능
- 도커는 재현 가능한 환경을 보장하므로, 로컬에서 잘 되던 애플리케이션이 리모트에서도 동일하게 작동
- 배포 및 업데이트도 단순:
  - 기존 컨테이너 종료
  - 새로운 이미지로 컨테이너 실행 → 끝
> 즉, 운영 환경 배포를 자동화하고 안정화하는 데 탁월

### 5-3. 로컬 ↔ 리모트: 동일한 도커 이미지로 동일한 환경 제공
| 구분   | 로컬 개발                           | 리모트 배포                         |
|--------|--------------------------------------|-------------------------------------|
| 목적   | 개발 환경 재현, 의존성 관리         | 사용자에게 서비스 제공              |
| 특징   | 실험과 테스트에 최적                | 간편한 롤백/업데이트 가능           |
| 예시   | 사이드 프로젝트, 팀 협업           | 실제 서비스 배포, CI/CD            |

### 5-4. 정리
- 도커는 개발과 배포 두 환경 모두에 유용함
- 로컬에서는 편리한 개발 환경 구성 도구
- 리모트에서는 일관된 배포와 운영 자동화 도구
- 도커는 단순히 배포용 도구가 아니라, 개발자 생산성을 높이는 전반적인 플랫폼

  
